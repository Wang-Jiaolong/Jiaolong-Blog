---
layout:     post
title:      "「LeeCode」1~100（简单题）"
subtitle:   "做题记录及思考"
author:     "Jalen"
header-img: "img/about-bg.jpg"
catalog: true
catalogDetail: false
tags:
    - LeeCode
---

# 1. Two Sum

> Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.
>
> You may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.
>
> You can return the answer in any order.
>
> **Example 1:**
>
> **Input:** nums = \[2,7,11,15\], target = 9
> **Output:** \[0,1\]
> **Output:** Because nums\[0\] + nums\[1\] == 9, we return \[0, 1\].
>
> **Example 2:**
>
> **Input:** nums = \[3,2,4\], target = 6
> **Output:** \[1,2\]
>
> **Example 3:**
>
> **Input:** nums = \[3,3\], target = 6
> **Output:** \[0,1\]
>
> **Constraints:**
>
> *   `2 <= nums.length <= 104`
> *   `-109 <= nums[i] <= 109`
> *   `-109 <= target <= 109`
> *   **Only one valid answer exists.**

## Solution

### Mine

~~~java
//Java
//暴力无脑双重for循环  时间复杂度：o(n^2)
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for(int i=0;i<nums.length-1;i++){
            for(int j=i+1;j<nums.length;j++){
                if(nums[i]+nums[j]==target){
                    return new int[] {i,j};
                }
            }
        }
         return new int[] {};
    }
}
~~~

### Others

~~~java
//Java
//使用哈希表 时间复杂度：o(n)
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<Integer, Integer>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(target - nums[i])){
                return new int[]{map.get(target - nums[i]),i};
            }
            map.put(nums[i],i);
        }
         return new int[] {};
    }
}
~~~

## notes：

> index的复数：indice或indexs
>
> 1. indexes在美国、加拿大等国的英语里比较常见。但indices盛行于除北美国家以外的英语里。
> 2. indices一般在数学，金融和相关领域使用，而indexes使用则相对广泛。

# 7. Reverse Integer

> Given a signed 32-bit integer `x`, return `x` _with its digits reversed_. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.
>
> **Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**
>
> **Example 1:**
>
> **Input:** x = 123
> **Output:** 321
>
> **Example 2:**
>
> **Input:** x = -123
> **Output:** -321
>
> **Example 3:**
>
> **Input:** x = 120
> **Output:** 21
>
> **Example 4:**
>
> **Input:** x = 0
> **Output:** 0
>
> **Constraints:**
>
> *   `-231 <= x <= 231 - 1`

## Solution

### Official

https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode-solution-bccn/

### Others

~~~java
//Java
class Solution {
    public int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            if (rev > Integer.MAX_VALUE / 10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
            if (rev < Integer.MIN_VALUE / 10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;
            rev = rev * 10 + pop;
            x /= 10;
        }
        return rev;
    }
}
~~~

> **思路**
> 标签：数学
>
> *   本题如果不考虑溢出问题，是非常简单的。解决溢出问题有两个思路，第一个思路是通过字符串转换加`try catch`的方式来解决，第二个思路就是通过数学计算来解决。
> *   由于字符串转换的效率较低且使用较多库函数，所以解题方案不考虑该方法，而是通过数学计算来解决。
> *   通过循环将数字`x`的每一位拆开，在计算新值时每一步都判断是否溢出。
> *   溢出条件有两个，一个是大于整数最大值`MAX_VALUE`，另一个是小于整数最小值`MIN_VALUE`，设当前计算结果为`ans`，下一位为`pop`。
> *   从`ans * 10 + pop > MAX_VALUE`这个溢出条件来看
>     *   当出现 `ans > MAX_VALUE / 10` 且 `还有pop需要添加` 时，则一定溢出
>     *   当出现 `ans == MAX_VALUE / 10` 且 `pop > 7` 时，则一定溢出，`7`是`2^31 - 1`的个位数
> *   从`ans * 10 + pop < MIN_VALUE`这个溢出条件来看
>     *   当出现 `ans < MIN_VALUE / 10` 且 `还有pop需要添加` 时，则一定溢出
>     *   当出现 `ans == MIN_VALUE / 10` 且 `pop < -8` 时，则一定溢出，`8`是`-2^31`的个位数



# 9. Palindrome Number

> Given an integer `x`, return `true` if `x` is palindrome integer.
>
> An integer is a **palindrome** when it reads the same backward as forward. For example, `121` is palindrome while `123` is not.
>
> **Example 1:**
>
> **Input:** x = 121
> **Output:** true
>
> **Example 2:**
>
> **Input:** x = -121
> **Output:** false
> **Explanation:** From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
>
> **Example 3:**
>
> **Input:** x = 10
> **Output:** false
> **Explanation:** Reads 01 from right to left. Therefore it is not a palindrome.
>
> **Example 4:**
>
> **Input:** x = -101
> **Output:** false
>
> **Constraints:**
>
> *   `-231 <= x <= 231 - 1`
>
> **Follow up:** Could you solve it without converting the integer to a string?

## Solution

### Mine

~~~java
//Java
//利用转换字符串无脑判断
public boolean isPalindrome(int x) {
    String str = String.valueOf(x);
    if (str.equals(new StringBuilder(str).reverse().toString())) {
        return true;
    } else {
        return false;
    }
}
~~~

> 利用StringBuilder反转字符串：`new StringBuilder(str).reverse().toString())` 

### Official

~~~java
//Java
//判断数字
public boolean isPalindrome(int x) {
    if (x < 0 || (x % 10 == 0 && x != 0)) return false;
    int reverse = 0;
    while (x > reverse) {
        reverse = reverse * 10 + x % 10;
        x /= 10;
    }
    return x == reverse || x == reverse / 10;
}
~~~

# 13. Roman to Integer

> Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.
>
> **Symbol**       **Value**
> I             1
> V             5
> X             10
> L             50
> C             100
> D             500
> M             1000
>
> For example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.
>
> Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:
>
> *   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. 
> *   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. 
> *   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.
>
> Given a roman numeral, convert it to an integer.
>
> **Example 1:**
>
> **Input:** s = "III"
> **Output:** 3
>
> **Example 2:**
>
> **Input:** s = "IV"
> **Output:** 4
>
> **Example 3:**
>
> **Input:** s = "IX"
> **Output:** 9
>
> **Example 4:**
>
> **Input:** s = "LVIII"
> **Output:** 58
> **Explanation:** L = 50, V= 5, III = 3.
>
> **Example 5:**
>
> **Input:** s = "MCMXCIV"
> **Output:** 1994
> **Explanation:** M = 1000, CM = 900, XC = 90 and IV = 4.
>
> **Constraints:**
>
> *   `1 <= s.length <= 15`
> *   `s` contains only the characters `('I', 'V', 'X', 'L', 'C', 'D', 'M')`.
> *   It is **guaranteed** that `s` is a valid roman numeral in the range `[1, 3999]`.****

## Solution

### Mine

~~~java
//Java
class Solution {
    public int romanToInt(String s) {
        char[] charArray = s.toCharArray();
        int result = 0;
        for (int i = 0; i < charArray.length; i++) {
            switch (charArray[i]) {
                case 'M':
                    result += 1000;
                    break;
                case 'D':
                    result += 500;
                    break;
                case 'L':
                    result += 50;
                    break;
                case 'V':
                    result += 5;
                    break;
                case 'C':
                    if (i + 1 < charArray.length) {
                        if (charArray[i + 1] == 'M') {
                            result += 900;
                            i++;
                            break;
                        } else if (charArray[i + 1] == 'D') {
                            result += 400;
                            i++;
                            break;
                        }
                    }
                    result += 100;
                    break;

                case 'X':
                    if (i + 1 < charArray.length) {
                        if (charArray[i + 1] == 'C') {
                            result += 90;
                            i++;
                            break;
                        } else if (charArray[i + 1] == 'L') {
                            result += 40;
                            i++;
                            break;
                        }
                    }
                    result += 10;
                    break;

                case 'I':
                    if (i + 1 < charArray.length) {
                        if (charArray[i + 1] == 'X') {
                            result += 9;
                            i++;
                            break;
                        } else if (charArray[i + 1] == 'V') {
                            result += 4;
                            i++;
                            break;
                        }
                    }
                    result += 1;
                    break;
            }
        }
        return result;
    }
}
~~~

> String转char数组：`char[] charArray=str.toCharArray();`
>
> char数组转String：`String.valueOf(charArray);`

### Offical

> 思路
>
> 通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。
>
> 例如`XXVII`可视作X+X+V+I+I=10+10+5+1+1=27。
>
> 若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。
>
> 例如 `XIV` 可视作10 -1+5=14X−I+V=10−1+5=14。
>

~~~java
//Java
class Solution {
    Map<Character, Integer> symbolValues = new HashMap<Character, Integer>() {{
        put('I', 1);
        put('V', 5);
        put('X', 10);
        put('L', 50);
        put('C', 100);
        put('D', 500);
        put('M', 1000);
    }};

    public int romanToInt(String s) {
        int ans = 0;
        int n = s.length();
        for (int i = 0; i < n; ++i) {
            int value = symbolValues.get(s.charAt(i));
            if (i < n - 1 && value < symbolValues.get(s.charAt(i + 1))) {
                ans -= value;
            } else {
                ans += value;
            }
        }
        return ans;
    }
}
~~~

# 14. Longest Common Prefix

> Write a function to find the longest common prefix string amongst an array of strings.
>
> If there is no common prefix, return an empty string `""`.
>
> **Example 1:**
>
> **Input:** strs = \["flower","flow","flight"\]
> **Output:** "fl"
>
> **Example 2:**
>
> **Input:** strs = \["dog","racecar","car"\]
> **Output:** ""
> **Explanation:** There is no common prefix among the input strings.
>
> **Constraints:**
>
> *   `1 <= strs.length <= 200`
> *   `0 <= strs[i].length <= 200`
> *   `strs[i]` consists of only lower-case English letters.

## Solution

### Mine

~~~java
//java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        int n = strs[0].length();
        char[] array = strs[0].toCharArray();
        String result = "";
        for (int i = 0; i < n; i++) {
            char current = array[i];
            boolean flag = true;
            for (int j = 0; j < strs.length; j++) {
                if (strs[j].length() == i || strs[j].charAt(i) != current) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                result += current;
            } else {
                break;
            }
        }
        return result;
    }
}
~~~

> String中获取指定位置字符：`str.charAt(index)`

### Offical

~~~java
//横向查找
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs[0].equals("") || strs.length == 0) {
            return "";
        }
        int n = strs.length;
        String result = strs[0];
        for (int i = 1; i < n; i++) {
            result = longestCommonPrefix(result, strs[i]);
            if (result.length() == 0) {
                break;
            }
        }
        return result;
    }

    public String longestCommonPrefix(String str1, String str2) {
        int length = Math.min(str1.length(), str2.length());
        int index = 0;

        while (index < length && str1.charAt(index) == str2.charAt(index)) {
            index++;
        }
        return str1.substring(0, index);
    }
}
~~~



//todo 二分查找



### Others

> sort会根据字符排序，直需要比较头尾即可

~~~c++
//C++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty()) return string();
        sort(strs.begin(), strs.end());
        string st = strs.front(), en = strs.back();
        int i, num = min(st.size(), en.size());
        for(i = 0; i < num && st[i] == en[i]; i ++);
        return string(st, 0, i);
    }
};
~~~

## Notes



# 14.

> 

## Solution

### Mine

### Offical

## Notes

