---
layout:     post
title:      "「LeeCode」1~100（简单题）"
subtitle:   "做题记录及思考"
author:     "Jalen"
header-img: "img/about-bg.jpg"
catalog: true
tags:
    - LeeCode
---

# 1. Two Sum

> Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.
>
> You may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.
>
> You can return the answer in any order.
>
> **Example 1:**
>
> **Input:** nums = \[2,7,11,15\], target = 9
> **Output:** \[0,1\]
> **Output:** Because nums\[0\] + nums\[1\] == 9, we return \[0, 1\].
>
> **Example 2:**
>
> **Input:** nums = \[3,2,4\], target = 6
> **Output:** \[1,2\]
>
> **Example 3:**
>
> **Input:** nums = \[3,3\], target = 6
> **Output:** \[0,1\]
>
> **Constraints:**
>
> *   `2 <= nums.length <= 104`
> *   `-109 <= nums[i] <= 109`
> *   `-109 <= target <= 109`
> *   **Only one valid answer exists.**



## Solution

### My

~~~java
//暴力无脑双重for循环  时间复杂度：o(n^2)
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for(int i=0;i<nums.length-1;i++){
            for(int j=i+1;j<nums.length;j++){
                if(nums[i]+nums[j]==target){
                    return new int[] {i,j};
                }
            }
        }
         return new int[] {};
    }
}
~~~

### Others

~~~java
//使用哈希表 时间复杂度：o(n)
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<Integer, Integer>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(target - nums[i])){
                return new int[]{map.get(target - nums[i]),i};
            }
            map.put(nums[i],i);
        }
         return new int[] {};
    }
}
~~~



## notes：

> index的复数：indice或indexs
>
> 1. indexes在美国、加拿大等国的英语里比较常见。但indices盛行于除北美国家以外的英语里。
> 2. indices一般在数学，金融和相关领域使用，而indexes使用则相对广泛。

# 7. Reverse Integer

> Given a signed 32-bit integer `x`, return `x` _with its digits reversed_. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.
>
> **Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**
>
> **Example 1:**
>
> **Input:** x = 123
> **Output:** 321
>
> **Example 2:**
>
> **Input:** x = -123
> **Output:** -321
>
> **Example 3:**
>
> **Input:** x = 120
> **Output:** 21
>
> **Example 4:**
>
> **Input:** x = 0
> **Output:** 0
>
> **Constraints:**
>
> *   `-231 <= x <= 231 - 1`

## Solution

### 官方

https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode-solution-bccn/

### Others

~~~java
class Solution {
    public int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            if (rev > Integer.MAX_VALUE / 10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
            if (rev < Integer.MIN_VALUE / 10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;
            rev = rev * 10 + pop;
            x /= 10;
        }
        return rev;
    }
}
~~~

> ### 思路
>
> *   标签：数学
> *   本题如果不考虑溢出问题，是非常简单的。解决溢出问题有两个思路，第一个思路是通过字符串转换加`try catch`的方式来解决，第二个思路就是通过数学计算来解决。
> *   由于字符串转换的效率较低且使用较多库函数，所以解题方案不考虑该方法，而是通过数学计算来解决。
> *   通过循环将数字`x`的每一位拆开，在计算新值时每一步都判断是否溢出。
> *   溢出条件有两个，一个是大于整数最大值`MAX_VALUE`，另一个是小于整数最小值`MIN_VALUE`，设当前计算结果为`ans`，下一位为`pop`。
> *   从`ans * 10 + pop > MAX_VALUE`这个溢出条件来看
>     *   当出现 `ans > MAX_VALUE / 10` 且 `还有pop需要添加` 时，则一定溢出
>     *   当出现 `ans == MAX_VALUE / 10` 且 `pop > 7` 时，则一定溢出，`7`是`2^31 - 1`的个位数
> *   从`ans * 10 + pop < MIN_VALUE`这个溢出条件来看
>     *   当出现 `ans < MIN_VALUE / 10` 且 `还有pop需要添加` 时，则一定溢出
>     *   当出现 `ans == MIN_VALUE / 10` 且 `pop < -8` 时，则一定溢出，`8`是`-2^31`的个位数
